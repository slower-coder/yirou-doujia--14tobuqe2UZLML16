**阅读目录**

* [〇、两时间段比较的全部情况](#_label0)
* [一、判断两个时间段是否有交叉（交集）](#_label1)
* [二、取两个时间段的交叉部分（交集）](#_label2)
* [三、取两个时间段并集](#_label3)
* [四、取两个时间段的补集](#_label4)


---


[回到顶部](#_labelTop)## 〇、两时间段比较的全部情况


总共有如下图中的六种情况：


![](https://img2024.cnblogs.com/blog/1868241/202410/1868241-20241022175713953-1229748974.png)


下文将根据这六种情况进一步操作。


*注意，图中说的动态和固定两时间段，就是两个普通时间段，不区分主次，仅用作帮助理解。*


[回到顶部](#_labelTop):[蓝猫机场](https://fenfang.org)## 一、判断两个时间段是否有交叉（交集）


正常情况下，就是图中的 2、3、4、5 四种有交叉的情况。如果直接通过这四种情况判断的话，就需要四个判断条件组合，过于复杂，本文略过。


如果通过**逆向思维**的话，就只需要判断 1、6 两种情况。当然**推荐使用逆向思维，判断的情况比较少，也易于理解**，下边详细介绍下。


**判断两时间段不交叉的条件：**



```


|  | -- 动态结束时间 < 固定开始时间 |
| --- | --- |
|  | jieshusj_dt < kaishisj_gd -- 情况 1 |
|  | or |
|  | kaishisj_dt > jieshusj_gd -- 情况 6 |
|  | -- 动态开始时间 > 固定结束时间 |


```

那么，就可以**通过取反，得到两时间段有交叉的条件**：



```


|  | -- 动态结束时间 >= 固定开始时间 |
| --- | --- |
|  | jieshusj_dt >= kaishisj_gd |
|  | and |
|  | kaishisj_dt <= jieshusj_gd |
|  | -- 动态开始时间 <= 固定结束时间 |


```

[回到顶部](#_labelTop)## 二、取两个时间段的交叉部分（交集）


**前提条件：**通过了有交叉判断。也就是包含 2、3、4、5 四种情况。


然后，就需要分别比较两个时间段的开始时间和结束时间：


* 开始时间：取较大的那一个；
* 结束时间：取较小的那一个。



```


|  | -- 动态时间段示例：2024-10-16 ~ 2024-10-20 |
| --- | --- |
|  | select |
|  | -- 开始时间取较大的 |
|  | (Case When kaishisj_gd > '2024-10-16' Then kaishisj_gd Else '2024-10-16' End) kaishisj, |
|  | -- 结束时间取较小的 |
|  | (Case When jieshusj_gd < '2024-10-20' Then jieshusj_gd Else '2024-10-20' End) jieshusj |
|  | from table_name |


```

[回到顶部](#_labelTop)## 三、取两个时间段并集


取并集也需要分两种情况，就是是否有交叉。


* **第一种：无交叉**


直接将两个时间段进行‘或’运算即可。


* **第二种：有交叉**


此种情况也是分别比较两个时间段的开始时间和结束时间，但是取值和上一章节中刚好相反，：


* 开始时间：取较小的那一个；
* 结束时间：取较大的那一个。



```


|  | -- 动态时间段示例：2024-10-16 ~ 2024-10-20 |
| --- | --- |
|  | select |
|  | -- 开始时间取较小的 |
|  | (Case When kaishisj_gd > '2024-10-16' Then '2024-10-16' Else kaishisj_gd End) kaishisj, |
|  | -- 结束时间取较大的 |
|  | (Case When jieshusj_gd < '2024-10-20' Then '2024-10-20' Else jieshusj_gd End) jieshusj |
|  | from table_name |


```

[回到顶部](#_labelTop)## 四、取两个时间段的补集


首先，什么是补集？简单的示意图如下：


（其中，**全集**‘集合 B’包含‘集合 A’，那么图中**灰色部分就是‘集合 A’的补集**）


![](https://img2024.cnblogs.com/blog/1868241/202410/1868241-20241023150916646-1737200417.png)


所以，求补集的前提条件就是两个时间段的有包含关系，也就是情况 3、4。


* **情况 3：**


![](https://img2024.cnblogs.com/blog/1868241/202410/1868241-20241023153511763-553881092.png)



```


|  | -- 动态时间段示例：2024-10-16 ~ 2024-10-20 |
| --- | --- |
|  | select |
|  | kaishisj_gd,'2024-10-16' as jieshusj_new, -- 两个时间，组成新的时间段 |
|  | '2024-10-20' as kaishisj_new,jieshusj_gd  -- 两个时间，组成新的时间段 |
|  | from table_name |
|  | where kaishisj_gd < '2024-10-16' and jieshusj_gd > '2024-10-20' |


```

如上边的查询语句，可以得到四个时间，分别组成两个时间段，再进行后续个性化操作。


* **情况 4：**


![](https://img2024.cnblogs.com/blog/1868241/202410/1868241-20241023154409027-1258435633.png)



```


|  | -- 动态时间段示例：2024-10-16 ~ 2024-10-20 |
| --- | --- |
|  | select |
|  | '2024-10-16' as kaishisj_new, kaishisj_gd, -- 两个时间，组成新的时间段 |
|  | jieshusj_gd, '2024-10-20' as jiehsusj_new  -- 两个时间，组成新的时间段 |
|  | from table_name |
|  | where kaishisj_gd > '2024-10-16' and jieshusj_gd < '2024-10-20' |


```

如上边的查询语句，可以得到四个时间，分别组成两个时间段，再进行后续个性化操作。


